package lts.main.input_preprocessing;

import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

/**Holds the program parameters and provides an static initialization method from the arguments Strings passed to main().
 */
public class ProgramParameters {

	private String nodeFileName, edgeFileName, outputFileName;
	private AlgorithmType algorithm;
	private int positiveGraphs;
	private Double binSize;
	private Long seed;
	private boolean dateTimeInfo;
		
	public String getNodeFileName() {
		return nodeFileName;
	}

	public void setNodeFileName(String nodeFileName) {
		this.nodeFileName = nodeFileName;
	}

	public String getEdgeFileName() {
		return edgeFileName;
	}

	public void setEdgeFileName(String edgeFileName) {
		this.edgeFileName = edgeFileName;
	}

	public String getOutputFileName() {
		return outputFileName;
	}

	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}

	public AlgorithmType getAlgorithm() {
		return algorithm;
	}

	public void setAlgorithm(AlgorithmType algorithm) {
		this.algorithm = algorithm;
	}

	public int getPositiveGraphs() {
		return positiveGraphs;
	}

	public void setPositiveGraphs(int positiveGraphs) {
		this.positiveGraphs = positiveGraphs;
	}
	
	public Double getBinSize() {
		return binSize;
	}

	public void setBinSize(Double binSize) {
		this.binSize = binSize;
	}

	public Long getSeed() {
		return seed;
	}

	public void setSeed(Long seed) {
		this.seed = seed;
	}

	public boolean isDateTimeInfo() {
		return dateTimeInfo;
	}

	public void setDateTimeInfo(boolean dateTimeInfo) {
		this.dateTimeInfo = dateTimeInfo;
	}

	/** Initializes the program parameters. Will handle printing messages if required arguments are missing or unparseable.
	 * @param args The arguments passed to main().
	 * @return The program parameters or null if there was an error.
	 */
	public static ProgramParameters initFromArgsIfErrPrint(String[] args) {
		Options opts = new Options();
		opts.addOption("n", "nodes", true, 
				"REQUIRED String.\n" +
				"File containing nodes data.");
		opts.addOption("e", "edges", true, 
				"REQUIRED String.\n" +
				"File containing edges data.");
		opts.addOption("o", "out", true, 
				"OPTIONAL String.\n" +
				"Output file name. File name will be prefixed by \"FAST PROBE\", \"LTSBFS\", or \"LTSDFS\" " +
				"and written to .\\results. Running lts also generates output for its fastprobe step. " +
				"(Default value is the file name of the \"nodes\" argument)");
		opts.addOption("d", "date", false, 
				"OPTIONAL Flag.\n" +
				"If present, append date info to the output file name.");
		opts.addOption("p", "positive", true, 
				"REQUIRED Integer 32-bit.\n" +
				"Number of positive graphs, " +
				"the first N graphs identified in the nodes data file are consider positive.");
		opts.addOption("a", "algorithm", true,
				"REQUIRED String.\n" +
				"Either \"fastprobe\", \"ltsbfs\" (lts using breadth first search), " +
				"or \"ltsdfs\" (lts using depth first search). " +
				"Lts uses fastprobe as a substep. Fastprobe is always run breadth first.");
		opts.addOption("b", "binsize", true, 
				"OPTIONAL Decimal.\n" +
				"Size of score bins in the search history generated by fastprobe. " +
				"(Default value is 0.1)");
		opts.addOption("s", "seed", true, 
				"OPTIONAL Integer 64-bit.\n" +
				"If present, will randomly shuffle the initial single edge patterns " +
				"with this as the randomization seed. " +
				"This can make a nontrivial difference in the runtime and results.");
		
		ProgramParameters params = getParamsIfErrPrint(opts, args);
		
		if (params == null) {
			new HelpFormatter().printHelp("LTS", opts);
		}
		
		return params;
	}
	
	private static ProgramParameters getParamsIfErrPrint(Options opts, String[] args) {

		CommandLine cmd;
		try {
			cmd = new BasicParser().parse(opts, args);
		} catch (ParseException e) {
			e.printStackTrace();
			return null;
		}
		
		ProgramParameters params = new ProgramParameters();
		String arg;
		
		if ((arg = requireOption("nodes", cmd)) == null) return null;
		params.setNodeFileName(arg);
		
		if ((arg = requireOption("edges", cmd)) == null) return null;
		params.setEdgeFileName(arg);

		if (cmd.hasOption("out")) {
			params.setOutputFileName(cmd.getOptionValue("out"));
		}
		
		params.setDateTimeInfo(cmd.hasOption("date"));
		
		if ((arg = requireOption("positive", cmd)) == null) return null;
		int positive;
		try {
			positive = Integer.parseInt(arg);
		} catch (NumberFormatException e) {
			printInvalid("positive", arg);
			return null;
		}
		params.setPositiveGraphs(positive);
		
		if ((arg = requireOption("algorithm", cmd)) == null) return null;
		AlgorithmType algorithm;
		try {
			algorithm = AlgorithmType.valueOf(arg.toUpperCase());
		} catch (IllegalArgumentException e) {
			printInvalid("algorithm", arg);
			return null;
		}
		params.setAlgorithm(algorithm);
		
		if (cmd.hasOption("binsize")) {
			Double binSize;
			arg = cmd.getOptionValue("binsize");
			try {
				binSize = Double.parseDouble(arg);
			} catch (NumberFormatException e) {
				printInvalid("binsize", arg);
				return null;
			}
			params.setBinSize(binSize);
		}
		
		if (cmd.hasOption("seed")) {
			Long seed;
			arg = cmd.getOptionValue("seed");
			try {
				seed = Long.parseLong(arg);
			} catch (NumberFormatException e) {
				printInvalid("seed", arg);
				return null;
			}
			params.setSeed(seed);
		}
		
		return params;
	}

	private static String requireOption(String name, CommandLine cmd) {
		String optVal = cmd.hasOption(name) ? cmd.getOptionValue(name) : null;
		if (optVal == null) System.out.println("Argument for "+name+" is REQUIRED!");
		return optVal;
	}
	
	private static void printInvalid(String name, String value) {
		System.out.println("Argument for "+name+" ("+value+") is invalid!");
	}
	
}
