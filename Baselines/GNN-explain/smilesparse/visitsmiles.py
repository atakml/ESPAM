import networkx as nx

from smilesparse.smilesParser import smilesParser
from smilesparse.smilesVisitor import smilesVisitor


class UnknownIdentifier(Exception):
    pass


class Unsupported(Exception):
    pass


class VisitSmiles(smilesVisitor):
    """Visitor that evaluates an expression. Derives and overrides methods
    from ArithVisitor (generated by ANTLR4)."""

    def __init__(self):
        self._memory = dict()  # store id -> values
        self._bond_history = 100 * [None]
        self.log = list()
        self.node_count = 0
        self.graph = nx.Graph()

    SINGLE_BOND_LABEL = {"symbol": "H", "isotope": None, "class_": None}
    H_LABEL = {"symbol": "H", "isotope": None, "class_": None}

    # raise NotImplementedError("print_string")
    def new_node(self):
        self.node_count += 1
        return self.node_count

    def set_bond(self, left, bond, right):
        self.graph.add_edge(left, right, bond=bond)

    def create_atom(self, symbol: str, isotope=None, chiral=None, h_count=None, charge=0, class_=None):

        labels = {"symbol": symbol,
                  "isotope": isotope,
                  "charge": charge,
                  "h_count": h_count,
                  "class_": class_}
        node_number = self.new_node()
        self.graph.add_node(node_number, **labels)

        if chiral:
            self.log.append("chiral " + chiral + "not Supported\n")

        return node_number

    def visitSmiles(self, ctx: smilesParser.SmilesContext):
        self.graph = nx.Graph()
        self.graph.formula=ctx.getText()
        self.visit(ctx.chain())
        self.visit(ctx.terminator())
        return self.graph

    def visitBaseAtom(self, ctx: smilesParser.BaseAtomContext):
        return self.visit(ctx.getChild(0))

    # Visit a parse tree produced by smilesParser#wildcardAtom.
    def visitWildcardAtom(self, ctx: smilesParser.WildcardAtomContext):
        self.log.append("wildcardAtom" + ctx.getText() + "\n")
        raise Unsupported()
        # return create_atom("c")

    # Visit a parse tree produced by smilesParser#aliphatic_organic.
    def visitAliphatic_organic(self, ctx: smilesParser.Aliphatic_organicContext):
        return self.create_atom(ctx.getText())  # Done

    # Visit a parse tree produced by smilesParser#aromatic_organic.
    def visitAromatic_organic(self, ctx: smilesParser.Aromatic_organicContext):
        return self.create_atom(ctx.getText())  # done

    # Visit a parse tree produced by smilesParser#bracket_atom.
    def visitBracket_atom(self, ctx: smilesParser.Bracket_atomContext):
        isotope = self.visit if ctx.isotope() else None
        symbol = self.visit(ctx.symbol())
        chiral = self.visit(ctx.chiral()) if ctx.chiral() else None
        h_count = self.visit(ctx.hcount()) if ctx.hcount() else 0
        charge = self.visit(ctx.charge()) if ctx.charge() else 0
        class_ = self.visit(ctx.class_()) if ctx.class_() else None
        return self.create_atom(symbol, isotope, chiral, h_count, charge, class_)

    # Visit a parse tree produced by smilesParser#baseSymbol.
    def visitBaseSymbol(self, ctx: smilesParser.BaseSymbolContext):
        return self.visit(ctx.getChild(0))

    # Visit a parse tree produced by smilesParser#wildcardSymbol.
    def visitWildcardSymbol(self, ctx: smilesParser.WildcardSymbolContext):
        self.log.append("wildcard Symbol" + ctx.getText() + "\n")
        raise Unsupported("wildcard")

    # Visit a parse tree produced by smilesParser#isotope.
    def visitIsotope(self, ctx: smilesParser.IsotopeContext):
        return int(ctx.getText())  # done

    # Visit a parse tree produced by smilesParser#element_symbols.
    def visitElement_symbols(self, ctx: smilesParser.Element_symbolsContext):
        return ctx.getText()  # done

    # Visit a parse tree produced by smilesParser#aromatic_symbols.
    def visitAromatic_symbols(self, ctx: smilesParser.Aromatic_symbolsContext):
        return ctx.getText()  # done

    # Visit a parse tree produced by smilesParser#chiral.
    def visitChiral(self, ctx: smilesParser.ChiralContext):
        return ctx.getText()  # done

    # Visit a parse tree produced by smilesParser#multipleHCount.
    def visitHcount(self, ctx: smilesParser.HcountContext):
        if ctx.DIGIT():
            return int(str(ctx.DIGIT()))
        else:
            return 1

    # Visit a parse tree produced by smilesParser#charge.
    def visitCharge(self, ctx: smilesParser.ChargeContext):
        text = ctx.getText()
        if len(ctx.DIGIT()):
            return int(text)
        else:
            return int(text[0] + "1") * len(text)

    # Visit a parse tree produced by smilesParser#class_.
    def visitClass_(self, ctx: smilesParser.Class_Context):
        return int(ctx.getText())

    # Visit a parse tree produced by smilesParser#bond.
    def visitBond(self, ctx: smilesParser.BondContext):
        return ctx.getText()

    # Visit a parse tree produced by smilesParser#singleDigitRing.
    def visitRingbond(self, ctx: smilesParser.RingbondContext):
        bond = self.visit(ctx.bond())
        number = int(ctx.DIGIT(0).getText() +
                     (ctx.DIGIT(1).getText() if ctx.DIGIT(1) else ""))
        return bond, number

    # Visit a parse tree produced by smilesParser#branchedAtom.
    def visitBranchedAtom(self, ctx: smilesParser.BranchedAtomContext):
        atom = self.visit(ctx.atom())
        for bond in ctx.ringbond():
            b_type, bid = self.visit(bond)
            if self._bond_history[bid]:
                c_type, next_chain = self._bond_history[bid]
                if b_type == c_type or not (b_type and c_type):  # if they are not equal one have to be none
                    bond_type = b_type or c_type  # or equals the first non false/None Value
                elif (b_type, c_type) == ("/", "\\"):
                    bond_type = "\\"
                elif (b_type, c_type) == ("\\", "/"):
                    bond_type = "/"
                else:
                    self.log.append("different bondTypes at each side of the ring" + b_type + "and" +
                                    c_type + " " + ctx.getText())
                    raise Exception()
                self.set_bond(next_chain, bond_type, atom)
                self._bond_history[bid] = None
            else:
                self._bond_history[bid] = b_type, atom
        for branch in ctx.branch():
            bond, (begin, _) = self.visit(branch)
            self.set_bond(atom, bond, begin)
        return atom

    # Visit a parse tree produced by smilesParser#branch.
    def visitBranch(self, ctx: smilesParser.BranchContext):
        ch = self.visit(ctx.chain())
        bnd = self.visit(ctx.bond())
        return bnd, ch

        # Visit a parse tree produced by smilesParser#singleAtom.

    def visitSingleAtom(self, ctx: smilesParser.SingleAtomContext):
        val = self.visit(ctx.getChild(0))
        return val, val

    # Visit a parse tree produced by smilesParser#bondedChain.
    def visitBondedChain(self, ctx: smilesParser.BondedChainContext):
        bg, end = self.visit(ctx.chain())
        bond = self.visit(ctx.bond())
        br = self.visit(ctx.branchedAtom())
        self.set_bond(end, bond, br)
        return bg, br

    # Visit a parse tree produced by smilesParser#terminator.
    def visitTerminator(self, ctx: smilesParser.TerminatorContext):
        pass
